<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Foundry Stream Overlay Browser Source</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #00ff00;
    }
    
    #overlay-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    .overlay-item {
      position: absolute;
      background-color: transparent;
      color: inherit;
      padding: 4px 8px;
      border-radius: 4px;
      margin: 0;
      cursor: default;
      user-select: none;
    }
    
    /* Animation keyframes */
    @keyframes hover {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    .overlay-item.hover { animation: hover 2s infinite; }
    
    @keyframes glitch2 {
      0% { clip: rect(40px, 9999px, 50px, 0); transform: translate(0); }
      15% { clip: rect(10px, 9999px, 20px, 0); transform: translate(-5px, 5px); }
      30% { clip: rect(60px, 9999px, 70px, 0); transform: translate(5px, -5px); }
      45% { clip: rect(20px, 9999px, 30px, 0); transform: translate(-5px, 5px); }
      60% { clip: rect(50px, 9999px, 60px, 0); transform: translate(5px, -5px); }
      75% { clip: rect(30px, 9999px, 40px, 0); transform: translate(-5px, 5px); }
      100% { clip: rect(40px, 9999px, 50px, 0); transform: translate(0); }
    }
    .overlay-item.glitch { animation: glitch2 1.5s infinite; }
    
    @keyframes heartbeat {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.1); }
      50% { transform: scale(1.2); }
      75% { transform: scale(1.1); }
    }
    .overlay-item.heartbeat { animation: heartbeat 1.5s infinite; }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }
    .overlay-item.pulse { animation: pulse 1.5s infinite; }
    
    @keyframes rotate {
      0% { transform: rotate(0deg); }
      50% { transform: rotate(2deg); }
      100% { transform: rotate(0deg); }
    }
    .overlay-item.rotate { animation: rotate 2s infinite; }
    
    @keyframes wiggle {
      0% { transform: rotate(0deg); }
      25% { transform: rotate(3deg); }
      50% { transform: rotate(0deg); }
      75% { transform: rotate(-3deg); }
      100% { transform: rotate(0deg); }
    }
    .overlay-item.wiggle { animation: wiggle 1s infinite; }
    
    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    .overlay-item.flash { animation: flash 1s infinite; }
    
    @keyframes shake {
      0% { transform: translate(0, 0); }
      20% { transform: translate(-3px, 3px); }
      40% { transform: translate(3px, -3px); }
      60% { transform: translate(-3px, 3px); }
      80% { transform: translate(3px, -3px); }
      100% { transform: translate(0, 0); }
    }
    .overlay-item.shake { animation: shake 0.5s infinite; }
    
    @keyframes shimmer {
      0% { filter: brightness(1); }
      50% { filter: brightness(2.5); }
      100% { filter: brightness(1); }
    }
    .overlay-item.shimmer { animation: shimmer 2s infinite; }
    
    @keyframes slide {
      0% { transform: translateX(0); }
      50% { transform: translateX(5px); }
      100% { transform: translateX(0); }
    }
    .overlay-item.slide { animation: slide 3s infinite; }
    
    #connection-status {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background-color: rgba(0,0,0,0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      opacity: 0.7;
      z-index: 9999;
      transition: opacity 0.5s;
    }
    
    #connection-status.connected {
      background-color: rgba(0,128,0,0.5);
    }
    
    #connection-status.error {
      background-color: rgba(255,0,0,0.5);
    }
    
    #connection-status.hidden {
      opacity: 0;
    }
  </style>
</head>
<body>
  <div id="overlay-container"></div>
  <div id="connection-status">Initializing...</div>

  <script>
    // Generate a unique ID for this browser source
    function generateSourceId() {
      return 'source_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    }
    
    // Parse URL parameters
    function getUrlParameter(name) {
      name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
      const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
      const results = regex.exec(location.search);
      return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    }
    
    // Variables
    const sourceId = generateSourceId();
    const authKey = getUrlParameter('key');
    const bgColor = getUrlParameter('bg') || '#00ff00';
    let connectionStatus = 'initializing';
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    let overlayData = null;
    let statusTimeout;
    let pollingInterval = null;
    
    // Update the background color
    document.body.style.backgroundColor = bgColor === 'transparent' ? 'transparent' : bgColor;
    
    // Connection status element
    const statusElement = document.getElementById('connection-status');
    
    // Hide status after a delay
    function hideStatus() {
      if (statusTimeout) clearTimeout(statusTimeout);
      statusTimeout = setTimeout(() => {
        statusElement.classList.add('hidden');
      }, 5000);
    }
    
    // Show status
    function showStatus(message, type = 'info') {
      statusElement.textContent = message;
      statusElement.classList.remove('hidden', 'connected', 'error');
      
      if (type === 'connected') statusElement.classList.add('connected');
      if (type === 'error') statusElement.classList.add('error');
      
      hideStatus();
    }
    
    // Render the overlay with the received data
    function renderOverlay(data) {
      if (!data || !data.items) return;
      
      const container = document.getElementById('overlay-container');
      container.innerHTML = '';
      
      // Update background color if provided
      if (data.backgroundColour && bgColor !== 'transparent') {
        document.body.style.backgroundColor = data.backgroundColour;
      }
      
      // Render each item
      data.items.forEach(item => {
        if (item.hide) return;
        
        if (item.type === 'image') {
          const img = document.createElement('img');
          img.src = item.imagePath;
          img.className = `overlay-item ${item.animation || ''}`;
          img.style.cssText = `
            position: absolute;
            top: ${item.top || 0}px;
            left: ${item.left || 0}px;
            width: ${item.imageSize || 100}px;
            z-index: ${item.renderOrder || 1};
            animation-delay: ${item.animationDelay || 0}ms;
            animation-duration: ${item.animationDuration || 1.5}s;
          `;
          container.appendChild(img);
        } else {
          const div = document.createElement('div');
          div.className = `overlay-item ${item.animation || ''}`;
          div.style.cssText = `
            position: absolute;
            top: ${item.top || 0}px;
            left: ${item.left || 0}px;
            font-size: ${item.fontSize || 16}px;
            font-family: ${item.fontFamily || 'Arial, sans-serif'};
            color: ${item.fontColor || '#000000'};
            z-index: ${item.renderOrder || 1};
            font-weight: ${item.bold ? 'bold' : 'normal'};
            animation-delay: ${item.animationDelay || 0}ms;
            animation-duration: ${item.animationDuration || 1.5}s;
          `;
          div.textContent = item.type === 'static' ? item.content : item.data;
          container.appendChild(div);
        }
      });
    }
    
    // Get initial data from the Foundry window
    function getInitialData() {
      // Try to get a reference to the Foundry window
      const foundryWindow = window.opener || window.parent;
      
      if (!foundryWindow || foundryWindow === window) {
        showStatus('Cannot access Foundry window. Make sure this is opened from Foundry.', 'error');
        return null;
      }
      
      try {
        // Try to get the game data from the parent window
        // First, see if we can access the game object directly
        if (foundryWindow.game && foundryWindow.game.settings) {
          // We have access to the game object, try to get the overlay data
          
          // Get settings
          const layouts = foundryWindow.game.settings.get(MODULE_ID, "layouts") || {};
          const activeLayout = foundryWindow.game.settings.get(MODULE_ID, "activeLayout") || "Default";
          const backgroundColour = foundryWindow.game.settings.get(MODULE_ID, "backgroundColour");
          
          // Get actors for data items
          const items = (layouts[activeLayout] || []).map(item => {
            // Include animation properties
            const animation = item.animation || "none";
            const animationDelay = (item.animationDelay !== undefined) ? item.animationDelay : 0;
            const animationDuration = item.animationDuration || 1.5;
            
            if (item.type === "image") {
              return {
                type: "image",
                imagePath: item.imagePath || "",
                imageSize: item.imageSize || 100,
                top: item.top ?? 0,
                left: item.left ?? 0,
                hide: item.hide ?? false,
                order: item.order || 0,
                animation,
                animationDelay,
                animationDuration
              };
            } else if (item.type === "static") {
              return {
                type: "static",
                content: item.content || "",
                top: item.top ?? 0,
                left: item.left ?? 0,
                hide: item.hide ?? false,
                fontSize: item.fontSize || 16,
                bold: item.bold || false,
                fontFamily: item.fontFamily || "Arial, sans-serif",
                fontColor: item.fontColor || "#000000",
                order: item.order || 0,
                animation,
                animationDelay,
                animationDuration
              };
            } else {
              // Dynamic data items.
              const actor = foundryWindow.game.actors.get(item.actorId);
              if (!actor) return null;
              if (item.hide) return null;
              let textValue = (item.dataPath === "name")
                ? actor.name
                : foundryWindow.foundry.utils.getProperty(actor, item.dataPath);
              if (textValue === null || textValue === undefined) textValue = "N/A";
              return {
                type: "data",
                actorId: item.actorId,
                dataPath: item.dataPath,
                data: textValue,
                top: item.top ?? 0,
                left: item.left ?? 0,
                hide: item.hide ?? false,
                fontSize: item.fontSize || 16,
                bold: item.bold || false,
                fontFamily: item.fontFamily || "Arial, sans-serif",
                fontColor: item.fontColor || "#000000",
                order: item.order || 0,
                animation,
                animationDelay,
                animationDuration
              };
            }
          }).filter(Boolean);
          
          // Sort items in ascending order
          items.sort((a, b) => a.order - b.order);
          
          // Compute renderOrder so that items at the top of the config list appear in front
          const max = items.length;
          items.forEach((item, index) => {
            item.renderOrder = max - index;
          });
          
          return {
            authenticated: true,
            backgroundColour,
            items,
            timestamp: Date.now()
          };
        }
      } catch (error) {
        console.error('Error getting game data:', error);
      }
      
      return null;
    }
    
    // Listen for updates from the Foundry window
    function listenForUpdates() {
      window.addEventListener('message', (event) => {
        // Check if this is a valid message from our parent
        if (!event.data || !event.data.module || event.data.module !== 'foundrystreamoverlay') return;
        
        // Handle different message types
        if (event.data.type === 'update') {
          // Update received, render new data
          overlayData = event.data.data;
          renderOverlay(overlayData);
          showStatus('Updated: ' + new Date().toLocaleTimeString(), 'connected');
        }
      });
    }
    
    // Initialize connection and setup
    function initialize() {
      showStatus('Connecting to Foundry...', 'info');
      
      // Try to get initial data
      const data = getInitialData();
      
      if (data) {
        // Successfully got data
        connectionStatus = 'connected';
        overlayData = data;
        renderOverlay(data);
        showStatus('Connected to Foundry', 'connected');
        
        // Set up listener for future updates
        listenForUpdates();
      } else {
        // Could not get data, show error
        connectionStatus = 'error';
        showStatus('Could not connect to Foundry. This browser source must be opened directly from Foundry.', 'error');
      }
    }
    
    // Start the connection process when the page loads
    window.addEventListener('load', initialize);
  </script>
</body>
</html>